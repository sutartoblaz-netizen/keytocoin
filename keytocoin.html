<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>KTC Explorer â€“ Global P2P Mainnet</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
body{background:#0b0b0b;color:#00ff99;font-family:monospace;padding:15px}
h1,h2{color:#00ffaa}
.card{border:1px solid #00ff99;border-radius:10px;padding:10px;margin-bottom:10px}
small{color:#77ffcc}
button{background:#111;color:#00ff99;border:1px solid #00ff99;padding:5px 10px;border-radius:6px}
pre{white-space:pre-wrap;word-break:break-all}
.block{margin-bottom:6px}
</style>
</head>
<body>

<h1>ğŸ” KeytoCoin (KTC) Explorer</h1>
<small>Public Read-Only â€¢ Auto P2P â€¢ Browser-Only</small>

<div class="card">
<h2>ğŸ“Š Network</h2>
<div>Height: <b id="height">0</b></div>
<div>Supply: <b id="supply">0</b> KTC</div>
<div>Peers: <b id="peers">0</b></div>
</div>

<div class="card">
<h2>â›“ï¸ Latest Blocks</h2>
<div id="blocks"></div>
</div>

<div class="card">
<h2>ğŸ“¦ Block Detail</h2>
<pre id="detail">select block</pre>
</div>

<script>
/* ================= CORE ================= */
let chain=[{
  height:0,
  hash:"GENESIS",
  prevHash:"0",
  txs:[],
  ts:Date.now()
}];

let peers=[];
let channel=null;

/* ================= UI ================= */
function render(){
  height.textContent=chain.length-1;
  supply.textContent=((chain.length-1)*0.25).toFixed(2);
  peers.textContent=peers.length;

  blocks.innerHTML="";
  [...chain].reverse().slice(0,20).forEach(b=>{
    if(b.height===0) return;
    const d=document.createElement("div");
    d.className="block";
    d.innerHTML=`#${b.height} 
    <button onclick='show(${b.height})'>
    ${b.hash.slice(0,32)}â€¦
    </button>`;
    blocks.appendChild(d);
  });
}

function show(h){
  const b=chain.find(x=>x.height===h);
  detail.textContent=JSON.stringify(b,null,2);
}

/* ================= AUTO P2P ================= */
/* signaling via shared BroadcastChannel (same origin / IPFS) */
const bc=new BroadcastChannel("ktc-mainnet");

bc.onmessage=async e=>{
  const msg=e.data;

  if(msg.type==="OFFER"){
    const pc=mkPC();
    await pc.setRemoteDescription(msg.offer);
    const ans=await pc.createAnswer();
    await pc.setLocalDescription(ans);
    bc.postMessage({type:"ANSWER",answer:ans});
  }

  if(msg.type==="ANSWER" && pcLocal){
    await pcLocal.setRemoteDescription(msg.answer);
  }
};

let pcLocal=null;

function mkPC(){
  const pc=new RTCPeerConnection({
    iceServers:[{urls:"stun:stun.l.google.com:19302"}]
  });

  pc.ondatachannel=e=>{
    channel=e.channel;
    peers.push(channel);
    channel.onmessage=onMsg;
  };

  return pc;
}

async function connect(){
  pcLocal=mkPC();
  channel=pcLocal.createDataChannel("ktc");
  peers.push(channel);
  channel.onmessage=onMsg;

  const offer=await pcLocal.createOffer();
  await pcLocal.setLocalDescription(offer);

  bc.postMessage({type:"OFFER",offer});
}

function onMsg(e){
  const msg=JSON.parse(e.data);

  if(msg.type==="CHAIN"){
    if(msg.data.length>chain.length){
      chain=msg.data;
      render();
    }
  }

  if(msg.type==="BLOCK"){
    const last=chain.at(-1);
    if(
      msg.data.height===last.height+1 &&
      msg.data.prevHash===last.hash
    ){
      chain.push(msg.data);
      render();
    }
  }
}

/* ================= START ================= */
connect();
render();
</script>

</body>
</html>
